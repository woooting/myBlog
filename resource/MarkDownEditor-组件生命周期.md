# MarkDownEditor 组件生命周期详解

> **文档版本**: 1.0
> **更新日期**: 2025-02-05
> **组件路径**: `app/components/MarkDownEditor.client.vue`

---

## 目录

1. [组件架构概览](#组件架构概览)
2. [完整生命周期流程](#完整生命周期流程)
3. [关键时间节点](#关键时间节点)
4. [防护机制](#防护机制)
5. [Bug 修复记录](#bug-修复记录)

---

## 组件架构概览

### 依赖关系图

```
┌─────────────────────────────────────────────────────────────┐
│              MarkDownEditor.client.vue                       │
│  (UI 层：编辑器 + 草稿提示栏 + 工具栏)                        │
└───────────────────────────┬─────────────────────────────────┘
                            │ 调用
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                   useAutoSave.ts                             │
│  (逻辑层：防抖保存、localStorage 读写、草稿管理)              │
└─────────────────────────────────────────────────────────────┘
```

### 核心技术栈

| 技术 | 用途 |
|------|------|
| **TipTap** | 富文本编辑器核心 |
| **tiptap-markdown** | Markdown 导入/导出支持 |
| **lowlight** | 代码高亮 |
| **VueUse** | 防抖监听 |
| **localStorage** | 草稿持久化 |

### 相关文件

| 文件 | 职责 |
|------|------|
| `app/components/MarkDownEditor.client.vue` | 编辑器组件 |
| `app/composables/useAutoSave.ts` | 自动保存逻辑 |
| `app/composables/useDragAndDrop.ts` | 拖拽文件上传 |
| `app/composables/useMarkdownIO.ts` | Markdown 导入/导出 |

---

## 完整生命周期流程

### 第一阶段：组件创建

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          组件创建阶段                                    │
└─────────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  1. <script setup> 自上而下执行                                          │
├─────────────────────────────────────────────────────────────────────────┤
│  • defineProps / defineEmits - 定义接口                                  │
│  • const lowlight = createLowlight(common) - 代码高亮配置                 │
│  • const fileInputRef = ref(...) - 文件输入引用                          │
│  • const showRestoreDraft = ref(false) - 草稿提示状态                    │
└─────────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  2. useEditor() 调用 - 创建 TipTap 编辑器实例                            │
├─────────────────────────────────────────────────────────────────────────┤
│  useEditor({                                                            │
│    content: '',              ← 初始内容为空                               │
│    extensions: [...],        ← 配置扩展                                   │
│    onUpdate: (...) => emit('update:modelValue', editor.getHTML())       │
│    onCreate: () => {                                                    │
│      // 设置初始内容（如果有 props.modelValue）                          │
│      const initialValue = props.modelValue || ''                         │
│      if (initialValue) {                                                │
│        editor.value?.commands.setContent(initialValue)                   │
│      }                                                                   │
│      // 检查并显示草稿恢复选项                                            │
│      checkAndShowDraftOption()                                          │
│    }                                                                     │
│  })                                                                      │
│                                                                          │
│  ⚠️ 此时 editor.value 可能仍为 null（useEditor 返回是同步的，但编辑器    │
│     内部初始化是异步的，onCreate 回调会在编辑器准备好后调用）             │
└─────────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  3. useAutoSave() 调用 - 设置自动保存                                    │
├─────────────────────────────────────────────────────────────────────────┤
│  const autoSave = useAutoSave<string>(                                  │
│    {                                                                     │
│      storageKey: 'markdown-editor-draft',                               │
│      getValue: () => editor.value?.getHTML() || '',  ← 获取内容的函数   │
│      setValue: (value) => editor.value?.commands.setContent(value),      │
│      delay: 1000,                                                       │
│      isEmpty: (html) => { ... }  ← 空内容检测                            │
│    },                                                                    │
│    { watchDebounced, onBeforeUnmount, computed, unref }                 │
│  )                                                                       │
│                                                                          │
│  内部执行：                                                               │
│  • hasDraft computed 计算（检查 localStorage 是否有草稿）                 │
│  • watchDebounced 监听器创建 ← 立即执行 getter！                         │
│    └─→ getValue() 返回 ''（此时 editor 可能未就绪）                      │
│    └─→ 防抖 1 秒后触发回调                                              │
│  • setTimeout 设置 isInitialized = true（1.1秒后）                       │
└─────────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  4. 其他 Composables 初始化                                             │
├─────────────────────────────────────────────────────────────────────────┤
│  • useDragAndDrop - 拖拽文件上传                                         │
│  • useMarkdownIO - Markdown 导入/导出                                    │
└─────────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  5. computed 和 watch 定义                                               │
├─────────────────────────────────────────────────────────────────────────┤
│  • toolbarGroups computed - 工具栏配置                                   │
│  • watch(props.modelValue) - 监听外部传入内容变化                        │
│  • onBeforeUnmount(() => editor.value?.destroy())                       │
└─────────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                    TipTap 编辑器初始化完成                               │
│                   （onCreate 回调触发）                                  │
└─────────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  6. onCreate 回调执行顺序                                                │
├─────────────────────────────────────────────────────────────────────────┤
│  ① 如果有 props.modelValue，设置初始内容                                  │
│     editor.value?.commands.setContent(initialValue)                      │
│                                                                          │
│  ② 调用 checkAndShowDraftOption()                                        │
│     │                                                                    │
│     ├─→ 检查 props.modelValue ──→ 有值 → 不显示提示                      │
│     │                                                                    │
│     ├─→ 检查 editor.isEmpty ──→ 有内容 → 不显示提示                      │
│     │                                                                    │
│     └─→ 调用 autoSave.getDraft()                                         │
│         │                                                                │
│         ├─→ localStorage.getItem('markdown-editor-draft')                │
│         ├─→ JSON.parse()                                                 │
│         ├─→ isEmpty() 检查                                               │
│         │                                                                │
│         └─→ 有有效草稿 → showRestoreDraft.value = true                   │
│             → 显示黄色提示栏：「检测到未保存的草稿内容」                   │
└─────────────────────────────────────────────────────────────────────────┘
```

### 第二阶段：组件运行

```
═══════════════════════════════════════════════════════════════════════════
                            组件运行阶段
═══════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────┐
│  场景 A：用户在编辑器中输入内容                                           │
├─────────────────────────────────────────────────────────────────────────┤
│  用户输入 → 编辑器内容变化                                               │
│    │                                                                    │
│    ▼                                                                    │
│  onUpdate 回调触发                                                       │
│    │                                                                    │
│    ▼                                                                    │
│  emit('update:modelValue', editor.getHTML())                            │
│    │                                                                    │
│    ▼                                                                    │
│  watchDebounced 监听到 getValue() 变化                                   │
│    │                                                                    │
│    ▼ (1 秒防抖)                                                         │
│  防抖回调执行：                                                          │
│  │  • isEmpty(newValue) 检查                                            │
│  │  • 非空 → localStorage.setItem(key, JSON.stringify(newValue))        │
│  │  • 空 → if (isInitialized) localStorage.removeItem(key)               │
│  └─→ 草稿已保存 ✅                                                       │
│                                                                          │
│  用户继续输入 → 计时器重置 → 1 秒无输入后才保存                          │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│  场景 B：用户点击「恢复草稿」                                             │
├─────────────────────────────────────────────────────────────────────────┤
│  restoreDraft() 执行：                                                   │
│  │  • autoSave.restoreDraft() → setValue(draft)                         │
│  │    └─→ editor.value?.commands.setContent(draft)                      │
│  │  • showRestoreDraft.value = false → 隐藏提示栏                        │
│  └─→ 草稿内容已恢复到编辑器 ✅                                           │
│                                                                          │
│  之后用户输入内容 → 触发自动保存 → 草稿被更新                            │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│  场景 C：用户点击「放弃」                                                 │
├─────────────────────────────────────────────────────────────────────────┤
│  dismissDraft() 执行：                                                   │
│  │  • showRestoreDraft.value = false → 仅隐藏提示栏                      │
│  └─→ localStorage 中的草稿仍然存在！                                      │
│                                                                          │
│  下次打开编辑器时仍会提示恢复                                            │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│  场景 D：用户使用工具栏功能                                               │
├─────────────────────────────────────────────────────────────────────────┤
│  • 点击格式按钮（粗体、斜体等）→ 编辑器命令执行 → 触发自动保存            │
│  • 点击导入 → 触发文件选择 → 导入 Markdown 内容 → 触发自动保存            │
│  • 点击导出 → 调用 exportMarkdown() → 下载 .md 文件                      │
│  • 拖拽文件 → useDragAndDrop 处理 → 导入内容 → 触发自动保存              │
└─────────────────────────────────────────────────────────────────────────┘
```

### 第三阶段：组件销毁

```
═══════════════════════════════════════════════════════════════════════════
                          组件销毁阶段
═══════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────┐
│  用户离开页面 / 路由切换 / 组件卸载                                       │
└─────────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  1. onBeforeUnmount 钩子执行（组件级别）                                  │
├─────────────────────────────────────────────────────────────────────────┤
│  onBeforeUnmount(() => {                                                │
│    editor.value?.destroy()  ← 销毁 TipTap 编辑器实例                    │
│  })                                                                      │
└─────────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  2. useAutoSave 的 onBeforeUnmount 执行                                  │
├─────────────────────────────────────────────────────────────────────────┤
│  vueApis.onBeforeUnmount(() => {                                        │
│    if (vueApis.unref(enabled) === false) return                         │
│    stop()  ← 停止防抖监听器                                             │
│    const value = getValue()  ← 获取最后的内容                            │
│    if (isEmpty && isEmpty(value)) {                                     │
│      localStorage.removeItem(storageKey)  ← 空内容则清除                 │
│    } else {                                                             │
│      localStorage.setItem(storageKey, JSON.stringify(value)) ← 保存    │
│    }                                                                     │
│  })                                                                      │
│                                                                          │
│  ⚠️ 这是最后的机会保存数据，确保页面刷新时不会丢失                        │
└─────────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  3. 组件实例销毁                                                         │
├─────────────────────────────────────────────────────────────────────────┤
│  • 所有 ref 解引用                                                      │
│  • 监听器停止                                                           │
│  • 编辑器 DOM 元素移除                                                  │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 关键时间节点

| 时间点 | 事件 | 重要状态 |
|--------|------|----------|
| T+0ms | 组件开始创建 | `editor.value = null` |
| T+?ms | `useEditor` 返回 | `editor.value` 可用，但内部未就绪 |
| T+?ms | `useAutoSave` 初始化 | 监听器启动，`isInitialized = false` |
| T+?ms | TipTap 内部初始化完成 | `onCreate` 回调触发 |
| T+?ms | `checkAndShowDraftOption()` | 可能显示草稿提示 |
| T+0ms | 防抖监听器首次执行 | `getValue()` 返回空 |
| T+1000ms | 防抖回调首次触发 | **但因 `isInitialized=false` 不会删除草稿** |
| T+1100ms | 初始化保护结束 | `isInitialized = true` ✅ |
| 用户输入后 | 内容变化 + 1秒防抖 | 正常保存草稿 |
| 组件卸载时 | `onBeforeUnmount` | 最后保存机会 |

---

## 防护机制

### 初始化保护

```
初始化阶段（0-1100ms）：
┌────────────────────────────────────────────────┐
│  isInitialized = false                         │
│  ├─→ 防抖回调：isEmpty=true → 不删除草稿 ✅     │
│  └─→ 保护用户已有的草稿不被误删                 │
└────────────────────────────────────────────────┘

正常运行阶段（1100ms 后）：
┌────────────────────────────────────────────────┐
│  isInitialized = true                          │
│  ├─→ 防抖回调：isEmpty=true → 删除草稿 ✅       │
│  └─→ 用户主动清空内容时，清理无效草稿           │
└────────────────────────────────────────────────┘
```

### isEmpty 检查逻辑

```typescript
isEmpty: (html) => {
  // TipTap 空编辑器会产生以下模式
  const emptyPatterns = ['<p></p>', '<p><br></p>', '<p> </p>', '']
  const trimmed = html.trim()
  if (emptyPatterns.includes(trimmed)) return true
  // 检查是否只包含空白标签
  return /^<p>\s*<\/p>$/.test(trimmed)
}
```

---

## Bug 修复记录

### Bug 1: 草稿被异常清除

**问题描述**：路由切换/页面刷新后，localStorage 中的草稿被自动清除

**根因**：
- `watchDebounced` 在组件挂载时立即执行 getter
- 此时编辑器可能返回初始空值 `<p></p>`
- 防抖 1 秒后触发检查，`isEmpty()` 返回 `true`
- 导致已有草稿被误删

**修复方案**：
```typescript
// 添加初始化完成标志
let isInitialized = false
setTimeout(() => {
  isInitialized = true
}, delay + 100)  // 比防抖时间稍长

// 防抖回调中检查
if (isEmpty && isEmpty(newValue)) {
  if (isInitialized) {  // 只有初始化完成后才清除
    localStorage.removeItem(storageKey)
  }
  return
}
```

### Bug 2: HTML 显示为纯文本

**问题描述**：恢复草稿时，`<p>123</p>` 被显示为文本而非渲染后的内容

**根因**：
- Markdown 扩展配置 `html: false`
- 导致 HTML 标签被当作纯文本处理

**修复方案**：
```typescript
Markdown.configure({
  html: true,  // 允许解析 HTML
  transformPastedText: true,
  transformCopiedText: true,
})
```

---

## 使用示例

### 基础用法

```vue
<template>
  <MarkDownEditor
    v-model="content"
    placeholder="开始编写你的文章..."
    storage-key="my-post-draft"
  />
</template>

<script setup>
const content = ref('')
</script>
```

### 禁用自动保存

```vue
<template>
  <MarkDownEditor
    v-model="content"
    :storage-key="undefined"
  />
</template>
```

---

## API 参考

### Props

| 属性 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `modelValue` | `string` | `''` | 编辑器内容（v-model） |
| `placeholder` | `string` | `'开始输入内容...'` | 占位符文本 |
| `storageKey` | `string` | `'markdown-editor-draft'` | localStorage 存储键 |

### Events

| 事件 | 参数 | 说明 |
|------|------|------|
| `update:modelValue` | `value: string` | 内容变化时触发 |

---

## 相关资源

- [TipTap 官方文档](https://tiptap.dev/)
- [VueUse 文档](https://vueuse.org/)
- [tiptap-markdown](https://github.com/ueberdaum/tiptap-markdown)
